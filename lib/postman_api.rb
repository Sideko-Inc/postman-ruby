# Generated by Sideko (sideko.dev)
# frozen_string_literal: true
require 'json'
require 'http'
require_relative 'schemas'

class RequestError < StandardError
  attr_reader :status_code, :method, :url, :data

  def initialize(status_code, method, url, message)
    @status_code = status_code
    @method = method
    @url = url
    begin
      @data = JSON.parse(message)
    rescue
      @data = message
    end

    super("received #{status_code} from #{method} #{url} with #{message}")
  end
end

class SidekoClient
  def initialize(api_key, base_url='https://api.getpostman.com')
    @_client = HTTP.persistent(nil)
    @_base_url = base_url
    # add key auth header
    @_client = @_client.headers('x-api-key' => api_key)
  end

  def _cast_array(input_array, target_class)
    casted = []
    input_array.each { |el|
      if el.class == Array
        casted.append(_cast_array(el, target_class))
      else
        casted.append(target_class.from_json!(JSON.generate(el)))
      end
    }
    casted
  end

  def delete_api(api_id:)
    url = @_base_url + "/apis/#{api_id}"
    params = {}

    
    response = @_client.delete(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="delete",
        url=url,
        message=response.reason,
      )
    end

    response
  end

  def delete_schema_file(api_id:, schema_id:, file_path:)
    url = @_base_url + "/apis/#{api_id}/schemas/#{schema_id}/files/#{file_path}"
    params = {}

    
    response = @_client.delete(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="delete",
        url=url,
        message=response.reason,
      )
    end

    response
  end

  def delete_api_version(api_id:, version_id:)
    url = @_base_url + "/apis/#{api_id}/versions/#{version_id}"
    params = {}

    
    response = @_client.delete(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="delete",
        url=url,
        message=response.reason,
      )
    end

    response
  end

  def delete_collection(collection_id:)
    url = @_base_url + "/collections/#{collection_id}"
    params = {}

    
    response = @_client.delete(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="delete",
        url=url,
        message=response.reason,
      )
    end

    response = DeleteCollectionsCollectionIDResponse.from_dynamic!(response)
    response
  end

  def delete_collection_folder(collection_id:, folder_id:)
    url = @_base_url + "/collections/#{collection_id}/folders/#{folder_id}"
    params = {}

    
    response = @_client.delete(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="delete",
        url=url,
        message=response.reason,
      )
    end

    response = DeleteCollectionsCollectionIDFoldersFolderIDResponse.from_dynamic!(response)
    response
  end

  def delete_collection_request(collection_id:, request_id:)
    url = @_base_url + "/collections/#{collection_id}/requests/#{request_id}"
    params = {}

    
    response = @_client.delete(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="delete",
        url=url,
        message=response.reason,
      )
    end

    response = DeleteCollectionsCollectionIDRequestsRequestIDResponse.from_dynamic!(response)
    response
  end

  def delete_collection_response(collection_id:, response_id:)
    url = @_base_url + "/collections/#{collection_id}/responses/#{response_id}"
    params = {}

    
    response = @_client.delete(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="delete",
        url=url,
        message=response.reason,
      )
    end

    response = DeleteCollectionsCollectionIDResponsesResponseIDResponse.from_dynamic!(response)
    response
  end

  def delete_environment(environment_id:)
    url = @_base_url + "/environments/#{environment_id}"
    params = {}

    
    response = @_client.delete(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="delete",
        url=url,
        message=response.reason,
      )
    end

    response = DeleteEnvironmentsEnvironmentIDResponse.from_dynamic!(response)
    response
  end

  def delete_mock(mock_id:)
    url = @_base_url + "/mocks/#{mock_id}"
    params = {}

    
    response = @_client.delete(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="delete",
        url=url,
        message=response.reason,
      )
    end

    response = DeleteMocksMockIDResponse.from_dynamic!(response)
    response
  end

  def delete_mock_server_response(mock_id:, server_response_id:)
    url = @_base_url + "/mocks/#{mock_id}/server-responses/#{server_response_id}"
    params = {}

    
    response = @_client.delete(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="delete",
        url=url,
        message=response.reason,
      )
    end

    response = DeleteMocksMockIDServerResponsesServerResponseIDResponse.from_dynamic!(response)
    response
  end

  def unpublish_mock(mock_id:)
    url = @_base_url + "/mocks/#{mock_id}/unpublish"
    params = {}

    
    response = @_client.delete(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="delete",
        url=url,
        message=response.reason,
      )
    end

    response = DeleteMocksMockIDUnpublishResponse.from_dynamic!(response)
    response
  end

  def delete_monitor(monitor_id:)
    url = @_base_url + "/monitors/#{monitor_id}"
    params = {}

    
    response = @_client.delete(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="delete",
        url=url,
        message=response.reason,
      )
    end

    response = DeleteMonitorsMonitorIDResponse.from_dynamic!(response)
    response
  end

  def remove_element_or_folder(element_type:, element_id:)
    url = @_base_url + "/network/private/#{element_type}/#{element_id}"
    params = {}

    
    response = @_client.delete(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="delete",
        url=url,
        message=response.reason,
      )
    end

    response = DeleteNetworkPrivateElementTypeElementIDResponse.from_dynamic!(response)
    response
  end

  def delete_group(group_id:)
    url = @_base_url + "/scim/v2/Groups/#{group_id}"
    params = {}

    
    response = @_client.delete(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="delete",
        url=url,
        message=response.reason,
      )
    end

    response
  end

  def delete_workspace(workspace_id:)
    url = @_base_url + "/workspaces/#{workspace_id}"
    params = {}

    
    response = @_client.delete(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="delete",
        url=url,
        message=response.reason,
      )
    end

    response = DeleteWorkspacesWorkspaceIDResponse.from_dynamic!(response)
    response
  end

  def get_all_apis(workspace_id:, created_by: nil, cursor: nil, description: nil, limit: nil)
    url = @_base_url + "/apis"
    params = {}
    params[:workspace_id] = workspace_id
    if created_by != nil
      params[:created_by] = created_by
    end
    if cursor != nil
      params[:cursor] = cursor
    end
    if description != nil
      params[:description] = description
    end
    if limit != nil
      params[:limit] = limit
    end

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetApisResponse.from_dynamic!(response)
    response
  end

  def get_an_api(api_id:, include: nil)
    url = @_base_url + "/apis/#{api_id}"
    params = {}
    if include != nil
      params[:include] = include
    end

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response
  end

  def get_collection(api_id:, collection_id:, version_id: nil)
    url = @_base_url + "/apis/#{api_id}/collections/#{collection_id}"
    params = {}
    if version_id != nil
      params[:version_id] = version_id
    end

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetApisAPIIDCollectionsCollectionIDResponse.from_dynamic!(response)
    response
  end

  def get_schema(api_id:, schema_id:, bundled: nil, version_id: nil)
    url = @_base_url + "/apis/#{api_id}/schemas/#{schema_id}"
    params = {}
    if bundled != nil
      params[:bundled] = bundled
    end
    if version_id != nil
      params[:version_id] = version_id
    end

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response
  end

  def get_schema_files(api_id:, schema_id:, cursor: nil, limit: nil, version_id: nil)
    url = @_base_url + "/apis/#{api_id}/schemas/#{schema_id}/files"
    params = {}
    if cursor != nil
      params[:cursor] = cursor
    end
    if limit != nil
      params[:limit] = limit
    end
    if version_id != nil
      params[:version_id] = version_id
    end

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetApisAPIIDSchemasSchemaIDFilesResponse.from_dynamic!(response)
    response
  end

  def get_schema_file_contents(api_id:, schema_id:, file_path:, version_id: nil)
    url = @_base_url + "/apis/#{api_id}/schemas/#{schema_id}/files/#{file_path}"
    params = {}
    if version_id != nil
      params[:version_id] = version_id
    end

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetApisAPIIDSchemasSchemaIDFilesFilePathResponse.from_dynamic!(response)
    response
  end

  def get_api_tags(api_id:)
    url = @_base_url + "/apis/#{api_id}/tags"
    params = {}

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetApisAPIIDTagsResponse.from_dynamic!(response)
    response
  end

  def get_status_of_an_async_task(api_id:, task_id:)
    url = @_base_url + "/apis/#{api_id}/tasks/#{task_id}"
    params = {}

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetApisAPIIDTasksTaskIDResponse.from_dynamic!(response)
    response
  end

  def get_all_versions(api_id:, cursor: nil, limit: nil)
    url = @_base_url + "/apis/#{api_id}/versions"
    params = {}
    if cursor != nil
      params[:cursor] = cursor
    end
    if limit != nil
      params[:limit] = limit
    end

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetApisAPIIDVersionsResponse.from_dynamic!(response)
    response
  end

  def get_api_version(api_id:, version_id:)
    url = @_base_url + "/apis/#{api_id}/versions/#{version_id}"
    params = {}

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetApisAPIIDVersionsVersionIDResponse.from_dynamic!(response)
    response
  end

  def get_audit_logs(cursor: nil, limit: nil, order_by: nil, since: nil, until_field: nil)
    url = @_base_url + "/audit/logs"
    params = {}
    if cursor != nil
      params[:cursor] = cursor
    end
    if limit != nil
      params[:limit] = limit
    end
    if order_by != nil
      params[:order_by] = order_by
    end
    if since != nil
      params[:since] = since
    end
    if until_field != nil
      params[:until_field] = until_field
    end

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetAuditLogsResponse.from_dynamic!(response)
    response
  end

  def all_collections(name: nil, workspace_id: nil)
    url = @_base_url + "/collections"
    params = {}
    if name != nil
      params[:name] = name
    end
    if workspace_id != nil
      params[:workspace_id] = workspace_id
    end

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetCollectionsResponse.from_dynamic!(response)
    response
  end

  def single_collection(collection_id:, access_key: nil)
    url = @_base_url + "/collections/#{collection_id}"
    params = {}
    if access_key != nil
      params[:access_key] = access_key
    end

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetCollectionsCollectionIDResponse.from_dynamic!(response)
    response
  end

  def get_collection_folder(collection_id:, folder_id:, ids: nil, populate: nil, uid: nil)
    url = @_base_url + "/collections/#{collection_id}/folders/#{folder_id}"
    params = {}
    if ids != nil
      params[:ids] = ids
    end
    if populate != nil
      params[:populate] = populate
    end
    if uid != nil
      params[:uid] = uid
    end

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetCollectionsCollectionIDFoldersFolderIDResponse.from_dynamic!(response)
    response
  end

  def get_collection_request(collection_id:, request_id:, ids: nil, populate: nil, uid: nil)
    url = @_base_url + "/collections/#{collection_id}/requests/#{request_id}"
    params = {}
    if ids != nil
      params[:ids] = ids
    end
    if populate != nil
      params[:populate] = populate
    end
    if uid != nil
      params[:uid] = uid
    end

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetCollectionsCollectionIDRequestsRequestIDResponse.from_dynamic!(response)
    response
  end

  def get_collection_response(collection_id:, response_id:, ids: nil, populate: nil, uid: nil)
    url = @_base_url + "/collections/#{collection_id}/responses/#{response_id}"
    params = {}
    if ids != nil
      params[:ids] = ids
    end
    if populate != nil
      params[:populate] = populate
    end
    if uid != nil
      params[:uid] = uid
    end

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetCollectionsCollectionIDResponsesResponseIDResponse.from_dynamic!(response)
    response
  end

  def get_collection_tags(collection_id:)
    url = @_base_url + "/collections/#{collection_id}/tags"
    params = {}

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetCollectionsCollectionIDTagsResponse.from_dynamic!(response)
    response
  end

  def transform_collection_to_open_api(collection_id:)
    url = @_base_url + "/collections/#{collection_id}/transformations"
    params = {}

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetCollectionsCollectionIDTransformationsResponse.from_dynamic!(response)
    response
  end

  def get_detected_secrets_locations(secret_id:, workspace_id:, cursor: nil, limit: nil)
    url = @_base_url + "/detected-secrets/#{secret_id}/locations"
    params = {}
    params[:workspace_id] = workspace_id
    if cursor != nil
      params[:cursor] = cursor
    end
    if limit != nil
      params[:limit] = limit
    end

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetDetectedSecretsSecretIDLocationsResponse.from_dynamic!(response)
    response
  end

  def all_environments(workspace_id: nil)
    url = @_base_url + "/environments"
    params = {}
    if workspace_id != nil
      params[:workspace_id] = workspace_id
    end

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetEnvironmentsResponse.from_dynamic!(response)
    response
  end

  def single_environment(environment_id:)
    url = @_base_url + "/environments/#{environment_id}"
    params = {}

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetEnvironmentsEnvironmentIDResponse.from_dynamic!(response)
    response
  end

  def api_key_owner()
    url = @_base_url + "/me"
    params = {}

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetMeResponse.from_dynamic!(response)
    response
  end

  def get_mocks(team_id: nil, workspace: nil)
    url = @_base_url + "/mocks"
    params = {}
    if team_id != nil
      params[:team_id] = team_id
    end
    if workspace != nil
      params[:workspace] = workspace
    end

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetMocksResponse.from_dynamic!(response)
    response
  end

  def get_mock(mock_id:)
    url = @_base_url + "/mocks/#{mock_id}"
    params = {}

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetMocksMockIDResponse.from_dynamic!(response)
    response
  end

  def get_mock_call_logs(mock_id:, cursor: nil, direction: nil, include: nil, limit: nil, request_method: nil, request_path: nil, response_status_code: nil, response_type: nil, since: nil, sort: nil, until_field: nil)
    url = @_base_url + "/mocks/#{mock_id}/call-logs"
    params = {}
    if cursor != nil
      params[:cursor] = cursor
    end
    if direction != nil
      params[:direction] = direction
    end
    if include != nil
      params[:include] = include
    end
    if limit != nil
      params[:limit] = limit
    end
    if request_method != nil
      params[:request_method] = request_method
    end
    if request_path != nil
      params[:request_path] = request_path
    end
    if response_status_code != nil
      params[:response_status_code] = response_status_code
    end
    if response_type != nil
      params[:response_type] = response_type
    end
    if since != nil
      params[:since] = since
    end
    if sort != nil
      params[:sort] = sort
    end
    if until_field != nil
      params[:until_field] = until_field
    end

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetMocksMockIDCallLogsResponse.from_dynamic!(response)
    response
  end

  def get_mock_server_responses(mock_id:)
    url = @_base_url + "/mocks/#{mock_id}/server-responses"
    params = {}

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = _cast_array(response, GetMocksMockIDServerResponsesResponseItem)
    response
  end

  def get_mock_server_response(mock_id:, server_response_id:)
    url = @_base_url + "/mocks/#{mock_id}/server-responses/#{server_response_id}"
    params = {}

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = _cast_array(response, GetMocksMockIDServerResponsesServerResponseIDResponseItem)
    response
  end

  def all_monitors(workspace: nil)
    url = @_base_url + "/monitors"
    params = {}
    if workspace != nil
      params[:workspace] = workspace
    end

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetMonitorsResponse.from_dynamic!(response)
    response
  end

  def single_monitor(monitor_id:)
    url = @_base_url + "/monitors/#{monitor_id}"
    params = {}

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetMonitorsMonitorIDResponse.from_dynamic!(response)
    response
  end

  def get_all_elements_and_folders(added_by: nil, created_by: nil, description: nil, direction: nil, limit: nil, name: nil, offset: nil, parent_folder_id: nil, since: nil, sort: nil, summary: nil, type: nil, until_field: nil)
    url = @_base_url + "/network/private"
    params = {}
    if added_by != nil
      params[:added_by] = added_by
    end
    if created_by != nil
      params[:created_by] = created_by
    end
    if description != nil
      params[:description] = description
    end
    if direction != nil
      params[:direction] = direction
    end
    if limit != nil
      params[:limit] = limit
    end
    if name != nil
      params[:name] = name
    end
    if offset != nil
      params[:offset] = offset
    end
    if parent_folder_id != nil
      params[:parent_folder_id] = parent_folder_id
    end
    if since != nil
      params[:since] = since
    end
    if sort != nil
      params[:sort] = sort
    end
    if summary != nil
      params[:summary] = summary
    end
    if type != nil
      params[:type] = type
    end
    if until_field != nil
      params[:until_field] = until_field
    end

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetNetworkPrivateResponse.from_dynamic!(response)
    response
  end

  def get_all_add_element_requests(direction: nil, limit: nil, name: nil, offset: nil, requested_by: nil, since: nil, sort: nil, status: nil, type: nil, until_field: nil)
    url = @_base_url + "/network/private/network-entity/request/all"
    params = {}
    if direction != nil
      params[:direction] = direction
    end
    if limit != nil
      params[:limit] = limit
    end
    if name != nil
      params[:name] = name
    end
    if offset != nil
      params[:offset] = offset
    end
    if requested_by != nil
      params[:requested_by] = requested_by
    end
    if since != nil
      params[:since] = since
    end
    if sort != nil
      params[:sort] = sort
    end
    if status != nil
      params[:status] = status
    end
    if type != nil
      params[:type] = type
    end
    if until_field != nil
      params[:until_field] = until_field
    end

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetNetworkPrivateNetworkEntityRequestAllResponse.from_dynamic!(response)
    response
  end

  def fetch_all_group_resources(count: nil, filter: nil, start_index: nil)
    url = @_base_url + "/scim/v2/Groups"
    params = {}
    if count != nil
      params[:count] = count
    end
    if filter != nil
      params[:filter] = filter
    end
    if start_index != nil
      params[:start_index] = start_index
    end

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetScimV2GroupsResponse.from_dynamic!(response)
    response
  end

  def fetch_group_resource(group_id:)
    url = @_base_url + "/scim/v2/Groups/#{group_id}"
    params = {}

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetScimV2GroupsGroupIDResponse.from_dynamic!(response)
    response
  end

  def get_resource_types()
    url = @_base_url + "/scim/v2/ResourceTypes"
    params = {}

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = _cast_array(response, GetScimV2ResourceTypesResponseItem)
    response
  end

  def service_provider_config()
    url = @_base_url + "/scim/v2/ServiceProviderConfig"
    params = {}

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetScimV2ServiceProviderConfigResponse.from_dynamic!(response)
    response
  end

  def fetch_all_user_resources(count: nil, filter: nil, start_index: nil)
    url = @_base_url + "/scim/v2/Users"
    params = {}
    if count != nil
      params[:count] = count
    end
    if filter != nil
      params[:filter] = filter
    end
    if start_index != nil
      params[:start_index] = start_index
    end

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetScimV2UsersResponse.from_dynamic!(response)
    response
  end

  def fetch_user_resource(user_id:)
    url = @_base_url + "/scim/v2/Users/#{user_id}"
    params = {}

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetScimV2UsersUserIDResponse.from_dynamic!(response)
    response
  end

  def get_secret_types()
    url = @_base_url + "/secret-types"
    params = {}

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetSecretTypesResponse.from_dynamic!(response)
    response
  end

  def get_tagged_entities(slug:, cursor: nil, direction: nil, entity_type: nil, limit: nil)
    url = @_base_url + "/tags/#{slug}/entities"
    params = {}
    if cursor != nil
      params[:cursor] = cursor
    end
    if direction != nil
      params[:direction] = direction
    end
    if entity_type != nil
      params[:entity_type] = entity_type
    end
    if limit != nil
      params[:limit] = limit
    end

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetTagsSlugEntitiesResponse.from_dynamic!(response)
    response
  end

  def all_workspaces(type: nil)
    url = @_base_url + "/workspaces"
    params = {}
    if type != nil
      params[:type] = type
    end

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetWorkspacesResponse.from_dynamic!(response)
    response
  end

  def single_workspace(workspace_id:)
    url = @_base_url + "/workspaces/#{workspace_id}"
    params = {}

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetWorkspacesWorkspaceIDResponse.from_dynamic!(response)
    response
  end

  def get_workspace_global_variables(workspace_id:)
    url = @_base_url + "/workspaces/#{workspace_id}/global-variables"
    params = {}

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetWorkspacesWorkspaceIDGlobalVariablesResponse.from_dynamic!(response)
    response
  end

  def get_workspace_tags(workspace_id:)
    url = @_base_url + "/workspaces/#{workspace_id}/tags"
    params = {}

    
    response = @_client.get(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="get",
        url=url,
        message=response.reason,
      )
    end

    response = GetWorkspacesWorkspaceIDTagsResponse.from_dynamic!(response)
    response
  end

  def patch_collection(data:, collection_id:)
    url = @_base_url + "/collections/#{collection_id}"
    params = {}

    
    response = @_client.patch(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="patch",
        url=url,
        message=response.reason,
      )
    end

    response = PatchCollectionsCollectionIDResponse.from_dynamic!(response)
    response
  end

  def patch_scim_v2_groups_group_id(data:, group_id:)
    url = @_base_url + "/scim/v2/Groups/#{group_id}"
    params = {}

    
    response = @_client.patch(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="patch",
        url=url,
        message=response.reason,
      )
    end

    response = PatchScimV2GroupsGroupIDResponse.from_dynamic!(response)
    response
  end

  def update_user_state(data:, user_id:)
    url = @_base_url + "/scim/v2/Users/#{user_id}"
    params = {}

    
    response = @_client.patch(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="patch",
        url=url,
        message=response.reason,
      )
    end

    response = PatchScimV2UsersUserIDResponse.from_dynamic!(response)
    response
  end

  def create_api(data:, workspace_id:)
    url = @_base_url + "/apis"
    params = {}
    params[:workspace_id] = workspace_id

    
    response = @_client.post(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="post",
        url=url,
        message=response.reason,
      )
    end

    response = PostApisResponse.from_dynamic!(response)
    response
  end

  def add_collection(data:, api_id:)
    url = @_base_url + "/apis/#{api_id}/collections"
    params = {}

    
    response = @_client.post(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="post",
        url=url,
        message=response.reason,
      )
    end

    response = PostApisAPIIDCollectionsResponse.from_dynamic!(response)
    response
  end

  def create_api_schema(data:, api_id:)
    url = @_base_url + "/apis/#{api_id}/schemas"
    params = {}

    
    response = @_client.post(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="post",
        url=url,
        message=response.reason,
      )
    end

    response = PostApisAPIIDSchemasResponse.from_dynamic!(response)
    response
  end

  def create_api_version(data:, api_id:)
    url = @_base_url + "/apis/#{api_id}/versions"
    params = {}

    
    response = @_client.post(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="post",
        url=url,
        message=response.reason,
      )
    end

    response = PostApisAPIIDVersionsResponse.from_dynamic!(response)
    response
  end

  def create_collection(data:, workspace_id: nil)
    url = @_base_url + "/collections"
    params = {}
    if workspace_id != nil
      params[:workspace_id] = workspace_id
    end

    
    response = @_client.post(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="post",
        url=url,
        message=response.reason,
      )
    end

    response = PostCollectionsResponse.from_dynamic!(response)
    response
  end

  def create_a_fork(data:, collection_id:, workspace:)
    url = @_base_url + "/collections/fork/#{collection_id}"
    params = {}
    params[:workspace] = workspace

    
    response = @_client.post(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="post",
        url=url,
        message=response.reason,
      )
    end

    response = PostCollectionsForkCollectionIDResponse.from_dynamic!(response)
    response
  end

  def merge_a_fork(data:)
    url = @_base_url + "/collections/merge"
    params = {}

    
    response = @_client.post(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="post",
        url=url,
        message=response.reason,
      )
    end

    response = PostCollectionsMergeResponse.from_dynamic!(response)
    response
  end

  def create_collection_folder(data:, collection_id:)
    url = @_base_url + "/collections/#{collection_id}/folders"
    params = {}

    
    response = @_client.post(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="post",
        url=url,
        message=response.reason,
      )
    end

    response = PostCollectionsCollectionIDFoldersResponse.from_dynamic!(response)
    response
  end

  def create_collection_request(data:, collection_id:, folder_id: nil)
    url = @_base_url + "/collections/#{collection_id}/requests"
    params = {}
    if folder_id != nil
      params[:folder_id] = folder_id
    end

    
    response = @_client.post(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="post",
        url=url,
        message=response.reason,
      )
    end

    response = PostCollectionsCollectionIDRequestsResponse.from_dynamic!(response)
    response
  end

  def create_collection_response(data:, collection_id:, request_id:)
    url = @_base_url + "/collections/#{collection_id}/responses"
    params = {}
    params[:request_id] = request_id

    
    response = @_client.post(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="post",
        url=url,
        message=response.reason,
      )
    end

    response = PostCollectionsCollectionIDResponsesResponse.from_dynamic!(response)
    response
  end

  def detected_secrets_queries(data:, cursor: nil, include: nil, limit: nil)
    url = @_base_url + "/detected-secrets-queries"
    params = {}
    if cursor != nil
      params[:cursor] = cursor
    end
    if include != nil
      params[:include] = include
    end
    if limit != nil
      params[:limit] = limit
    end

    
    response = @_client.post(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="post",
        url=url,
        message=response.reason,
      )
    end

    response = PostDetectedSecretsQueriesResponse.from_dynamic!(response)
    response
  end

  def create_environment(data:, workspace_id: nil)
    url = @_base_url + "/environments"
    params = {}
    if workspace_id != nil
      params[:workspace_id] = workspace_id
    end

    
    response = @_client.post(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="post",
        url=url,
        message=response.reason,
      )
    end

    response = PostEnvironmentsResponse.from_dynamic!(response)
    response
  end

  def import_external_api_specification(data:, workspace_id: nil)
    url = @_base_url + "/import/openapi"
    params = {}
    if workspace_id != nil
      params[:workspace_id] = workspace_id
    end

    
    response = @_client.post(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="post",
        url=url,
        message=response.reason,
      )
    end

    response = PostImportOpenapiResponse.from_dynamic!(response)
    response
  end

  def create_mock(data:, workspace_id: nil)
    url = @_base_url + "/mocks"
    params = {}
    if workspace_id != nil
      params[:workspace_id] = workspace_id
    end

    
    response = @_client.post(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="post",
        url=url,
        message=response.reason,
      )
    end

    response = PostMocksResponse.from_dynamic!(response)
    response
  end

  def publish_mock(mock_id:)
    url = @_base_url + "/mocks/#{mock_id}/publish"
    params = {}

    
    response = @_client.post(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="post",
        url=url,
        message=response.reason,
      )
    end

    response = PostMocksMockIDPublishResponse.from_dynamic!(response)
    response
  end

  def create_server_response(data:, mock_id:)
    url = @_base_url + "/mocks/#{mock_id}/server-responses"
    params = {}

    
    response = @_client.post(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="post",
        url=url,
        message=response.reason,
      )
    end

    response = _cast_array(response, PostMocksMockIDServerResponsesResponseItem)
    response
  end

  def create_monitor(data:, workspace_id: nil)
    url = @_base_url + "/monitors"
    params = {}
    if workspace_id != nil
      params[:workspace_id] = workspace_id
    end

    
    response = @_client.post(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="post",
        url=url,
        message=response.reason,
      )
    end

    response = PostMonitorsResponse.from_dynamic!(response)
    response
  end

  def run_a_monitor(monitor_id:)
    url = @_base_url + "/monitors/#{monitor_id}/run"
    params = {}

    
    response = @_client.post(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="post",
        url=url,
        message=response.reason,
      )
    end

    response = PostMonitorsMonitorIDRunResponse.from_dynamic!(response)
    response
  end

  def post_element_or_folder(data:)
    url = @_base_url + "/network/private"
    params = {}

    
    response = @_client.post(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="post",
        url=url,
        message=response.reason,
      )
    end

    response
  end

  def create_group(data:)
    url = @_base_url + "/scim/v2/Groups"
    params = {}

    
    response = @_client.post(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="post",
        url=url,
        message=response.reason,
      )
    end

    response = PostScimV2GroupsResponse.from_dynamic!(response)
    response
  end

  def create_user(data:)
    url = @_base_url + "/scim/v2/Users"
    params = {}

    
    response = @_client.post(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="post",
        url=url,
        message=response.reason,
      )
    end

    response = PostScimV2UsersResponse.from_dynamic!(response)
    response
  end

  def schema_security_validation(data:)
    url = @_base_url + "/security/api-validation"
    params = {}

    
    response = @_client.post(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="post",
        url=url,
        message=response.reason,
      )
    end

    response = PostSecurityAPIValidationResponse.from_dynamic!(response)
    response
  end

  def create_webhook(data:, workspace_id: nil)
    url = @_base_url + "/webhooks"
    params = {}
    if workspace_id != nil
      params[:workspace_id] = workspace_id
    end

    
    response = @_client.post(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="post",
        url=url,
        message=response.reason,
      )
    end

    response = PostWebhooksResponse.from_dynamic!(response)
    response
  end

  def create_workspace(data:)
    url = @_base_url + "/workspaces"
    params = {}

    
    response = @_client.post(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="post",
        url=url,
        message=response.reason,
      )
    end

    response = PostWorkspacesResponse.from_dynamic!(response)
    response
  end

  def update_an_api(data:, api_id:)
    url = @_base_url + "/apis/#{api_id}"
    params = {}

    
    response = @_client.put(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="put",
        url=url,
        message=response.reason,
      )
    end

    response = PutApisAPIIDResponse.from_dynamic!(response)
    response
  end

  def sync_collection_with_schema(api_id:, collection_id:)
    url = @_base_url + "/apis/#{api_id}/collections/#{collection_id}/sync-with-schema-tasks"
    params = {}

    
    response = @_client.put(
      url,
      :params => params,
      
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="put",
        url=url,
        message=response.reason,
      )
    end

    response = PutApisAPIIDCollectionsCollectionIDSyncWithSchemaTasksResponse.from_dynamic!(response)
    response
  end

  def create_or_update_schema_file(data:, api_id:, schema_id:, file_path:)
    url = @_base_url + "/apis/#{api_id}/schemas/#{schema_id}/files/#{file_path}"
    params = {}

    
    response = @_client.put(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="put",
        url=url,
        message=response.reason,
      )
    end

    response = PutApisAPIIDSchemasSchemaIDFilesFilePathResponse.from_dynamic!(response)
    response
  end

  def update_api_tags(data:, api_id:)
    url = @_base_url + "/apis/#{api_id}/tags"
    params = {}

    
    response = @_client.put(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="put",
        url=url,
        message=response.reason,
      )
    end

    response = PutApisAPIIDTagsResponse.from_dynamic!(response)
    response
  end

  def update_api_version(data:, api_id:, version_id:)
    url = @_base_url + "/apis/#{api_id}/versions/#{version_id}"
    params = {}

    
    response = @_client.put(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="put",
        url=url,
        message=response.reason,
      )
    end

    response = PutApisAPIIDVersionsVersionIDResponse.from_dynamic!(response)
    response
  end

  def put_collection(data:, collection_id:)
    url = @_base_url + "/collections/#{collection_id}"
    params = {}

    
    response = @_client.put(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="put",
        url=url,
        message=response.reason,
      )
    end

    response = PutCollectionsCollectionIDResponse.from_dynamic!(response)
    response
  end

  def update_collection_folder(data:, collection_id:, folder_id:)
    url = @_base_url + "/collections/#{collection_id}/folders/#{folder_id}"
    params = {}

    
    response = @_client.put(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="put",
        url=url,
        message=response.reason,
      )
    end

    response = PutCollectionsCollectionIDFoldersFolderIDResponse.from_dynamic!(response)
    response
  end

  def update_collection_request(data:, collection_id:, request_id:)
    url = @_base_url + "/collections/#{collection_id}/requests/#{request_id}"
    params = {}

    
    response = @_client.put(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="put",
        url=url,
        message=response.reason,
      )
    end

    response = PutCollectionsCollectionIDRequestsRequestIDResponse.from_dynamic!(response)
    response
  end

  def update_collection_response(data:, collection_id:, response_id:)
    url = @_base_url + "/collections/#{collection_id}/responses/#{response_id}"
    params = {}

    
    response = @_client.put(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="put",
        url=url,
        message=response.reason,
      )
    end

    response = PutCollectionsCollectionIDResponsesResponseIDResponse.from_dynamic!(response)
    response
  end

  def update_collection_tags(data:, collection_id:)
    url = @_base_url + "/collections/#{collection_id}/tags"
    params = {}

    
    response = @_client.put(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="put",
        url=url,
        message=response.reason,
      )
    end

    response = PutCollectionsCollectionIDTagsResponse.from_dynamic!(response)
    response
  end

  def update_detected_secret_resolutions(data:, secret_id:)
    url = @_base_url + "/detected-secrets/#{secret_id}"
    params = {}

    
    response = @_client.put(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="put",
        url=url,
        message=response.reason,
      )
    end

    response = PutDetectedSecretsSecretIDResponse.from_dynamic!(response)
    response
  end

  def update_environment(data:, environment_id:)
    url = @_base_url + "/environments/#{environment_id}"
    params = {}

    
    response = @_client.put(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="put",
        url=url,
        message=response.reason,
      )
    end

    response = PutEnvironmentsEnvironmentIDResponse.from_dynamic!(response)
    response
  end

  def update_mock(data:, mock_id:)
    url = @_base_url + "/mocks/#{mock_id}"
    params = {}

    
    response = @_client.put(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="put",
        url=url,
        message=response.reason,
      )
    end

    response = PutMocksMockIDResponse.from_dynamic!(response)
    response
  end

  def update_server_response(data:, mock_id:, server_response_id:)
    url = @_base_url + "/mocks/#{mock_id}/server-responses/#{server_response_id}"
    params = {}

    
    response = @_client.put(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="put",
        url=url,
        message=response.reason,
      )
    end

    response = _cast_array(response, PutMocksMockIDServerResponsesServerResponseIDResponseItem)
    response
  end

  def update_monitor(data:, monitor_id:)
    url = @_base_url + "/monitors/#{monitor_id}"
    params = {}

    
    response = @_client.put(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="put",
        url=url,
        message=response.reason,
      )
    end

    response = PutMonitorsMonitorIDResponse.from_dynamic!(response)
    response
  end

  def respond_element_add_request(data:, request_id:)
    url = @_base_url + "/network/private/network-entity/request/#{request_id}"
    params = {}

    
    response = @_client.put(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="put",
        url=url,
        message=response.reason,
      )
    end

    response = PutNetworkPrivateNetworkEntityRequestRequestIDResponse.from_dynamic!(response)
    response
  end

  def put_element_or_folder(data:, element_type:, element_id:)
    url = @_base_url + "/network/private/#{element_type}/#{element_id}"
    params = {}

    
    response = @_client.put(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="put",
        url=url,
        message=response.reason,
      )
    end

    response
  end

  def update_user_information(data:, user_id:)
    url = @_base_url + "/scim/v2/Users/#{user_id}"
    params = {}

    
    response = @_client.put(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="put",
        url=url,
        message=response.reason,
      )
    end

    response = PutScimV2UsersUserIDResponse.from_dynamic!(response)
    response
  end

  def update_workspace(data:, workspace_id:)
    url = @_base_url + "/workspaces/#{workspace_id}"
    params = {}

    
    response = @_client.put(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="put",
        url=url,
        message=response.reason,
      )
    end

    response = PutWorkspacesWorkspaceIDResponse.from_dynamic!(response)
    response
  end

  def put_workspace_global_variables(data:, workspace_id:)
    url = @_base_url + "/workspaces/#{workspace_id}/global-variables"
    params = {}

    
    response = @_client.put(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="put",
        url=url,
        message=response.reason,
      )
    end

    response = PutWorkspacesWorkspaceIDGlobalVariablesResponse.from_dynamic!(response)
    response
  end

  def update_workspace_tags(data:, workspace_id:)
    url = @_base_url + "/workspaces/#{workspace_id}/tags"
    params = {}

    
    response = @_client.put(
      url,
      :params => params,
      :json => data
    )
    if response.status.success?
      response = response.parse
    else
      raise RequestError.new(
        status_code=response.status,
        method="put",
        url=url,
        message=response.reason,
      )
    end

    response = PutWorkspacesWorkspaceIDTagsResponse.from_dynamic!(response)
    response
  end


end